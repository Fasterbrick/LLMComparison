Overall Performance & Comparison:

Code Completeness: None of the models provided a fully complete and runnable solution that meets all requirements, especially the core pivot table generation logic. swift-full and swift-deepseek provided more elaborate structures but had flaws (UI mixing, incomplete logic). swift-deepcoder and swift-qwen2.5 provided simpler but incomplete structures. swift-granite was the least complete functional code but the fastest.
Code Quality: swift-deepseek offered a reasonably well-structured SwiftUI approach with good comments and next steps, despite the missing core logic. swift-deepcoder also provided good improvement suggestions. swift-full's quality suffered from mixing AppKit and SwiftUI. swift-qwen2.5 was clean but functionally incorrect regarding file loading. swift-granite relied on external/non-standard components.   
Performance (Speed): swift-granite was significantly faster in both total duration and token evaluation rate. swift-deepcoder and swift-full had moderate speeds. swift-deepseek and swift-qwen2.5 (the larger 32B parameter models) were noticeably slower.   
Best Overall Attempt (considering prompt adherence & structure): swift-deepseek seems the most promising starting point due to its better SwiftUI structure, inclusion of a sidebar concept, and file loading, despite being slow and needing the pivot logic implementation.   
In conclusion, while none produced a final solution, the models showed varying strengths. The smaller models (swift-deepcoder, swift-granite) were faster but produced less code/structure. The larger models (swift-deepseek, swift-qwen2.5) were slower but attempted more complex structures, though still incomplete or flawed. swift-full had a unique but incorrect approach mixing UI frameworks.